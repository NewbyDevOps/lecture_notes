# <p style="text-align: center">Структура Linux и команды</p>

<image src="./images/linux_filesys.jpg" alt="linux_filesys">

## 1. Структура Linux
Структура каталогов ОС Linux достаточно жёсткая. Она имеет иерархическую структуру. Т.е. все каталоги, в итоге, сводятся к единому каталогу root (/). 

<image src="./images/structure.jpg" alt="structure">

FHS (Filesystem Hierarchy Standard) — стандарт, унифицирующий местонахождение файлов и каталогов с общим назначением в файловой системе UNIX.
Некоторые каталоги и их назначение:
- / - корневой каталог, содержащий всю файловую иерархию.
- /bin - основные утилиты, необходимые как в однопользовательском режиме, так и при обычной работе всем пользователям.
 - /boot - загрузочные файлы
 - /dev - основные файлы устройств
 - /etc - общесистемные конфигурационные файлы
 - /home - содержит домашние каталоги пользователей, которые в свою очередь содержат персональные настройки и данные пользователя
 - /lib - основные библиотеки, необходимые для работы программ из /bin и /sbin.
 - /media - точки монтирования для сменных носителей, таких как CD-ROM, DVD-ROM
 - /mnt - содержит временно монтируемые файловые системы
 - /opt - дополнительное ПО
 - /proc - виртуальная файловая система, представляющая состояние ядра ОС и запущенных процессов в виде файлов
 - /root - домашний каталог пользователя root
 - /run - информация о системе с момента её загрузки, в том числе данные, необходимые для работы демонов
 - /sbin - основные системные программы для администрирования и настройки системы
 - /srv - данные для сервисов, предоставляемых системой
 - /sys - содержит информацию об устройствах, драйверах, а так же некоторых свойствах ядра
 - /tmp - временные файлы
 - /usr - вторичная иерархия для данных пользователя. Содержит большинство пользовательских приложений и утилит, используемых в многопользовательском режиме
- /var - изменяемые файлы, такие как файлы регистрации, временные почтовые файлы, файлы спулеров

Самые часто используемые каталоги:
- /etc - файлы настроек
- /var/log - логи
- /home/<user_name> - домашний каталог пользователя

### Варианты установки ПО в Linux
- Из исходных кодов  
В этом режиме есть возможность модифицировать ПО, возможность установки без прав администратора. Такой подход к установке ПО используется крайне редко т.к. в этом режиме очень долгий последующий поиск зависимостей и отсутствует контроль установленного ПО.

- Из пакетов  
Пакет это, по сути, архив который содержит в себе уже готовый, скомпилированный бинарный файл нашего ПО и перечень зависимостей. Установка пакета это просто распаковка архива и перепись файлов в нужное место нашей ОС. В этом режиме установки есть контроль версий ПО. Как правило, для работы с пакетами используются пакетные менеджеры.  
Для устрановки в этом режиме нужны права администратора, а пакеты создаются под определённый дистрибутив Linux.

- Из репозитория  
Репозиторий - это место, где хранятся и поддерживаются какие-либо данныые. Чаще всего данные в репозитории хранятся в виде файлов, доступных для дальнейшего распространения по сети.
Плюсы установки из репозитория: сразу виден перечень зависимостей, есть контроль установленного ПО, все зависимости автоматически устанавливаются из репозитория.

### Версии Linux
Официальной версии Linux не существует. Торвальдс Линус написал ядро ОС Linux, но это не вся ОС. Ричард Столлман создал проект GNU. GNU - это свободная UNIX-подобная ОС. В итоге получилсь следующая ситуация, что Торвальдс Линус создал ядро, а Ричард Столлман окружение ОС (ядро его ОС не дописано до сих пор). После объеденения этих двух проектов получилась GNU/Linux.

<image src="./images/gnu-linux.jpg" alt="linux">

На сайте http://www.kernel.org/ можно скачать последнюю, свежую версию ядра ОС Linux (vanilla kernel). Универсальная общественная лицензия GNU передаёт пограммное обеспечение в общественную собственность. Любой человек может скачать код ядра и ПО и модифицировать его, сделав свой дистрибутив Linux. 

Отличия дистрибутивов Linux:
- Разные версии ядра
- Разная структура каталогов
- Разные менеджеры пакетов
- Разный набор ПО

Некоторые популярные версии GNU/Linux:
- Red Hat/CentOS/Fedora
- Debian/Ubuntu
- Slackware
- Gentoo

## 2. Простейшие команды в Linux
BASH — Bourne-Again SHell, самый популярный командный интерпретатор в юниксоподобных системах, в особенности в GNU/Linux.
Наиболее популярные команды при работе с BASH:

`ls` - отображает информацию о директориях и файлах, находящихся в папках.
- `ls -l` - показать файлы списком
- `ls -a` - показать вместе со скрытыми файлами
- `ls -h` - показать размеры папок в удобном для чтения формате
- `ls -i` - показать номер индекса inode, в которой хранится этот файл
- `ls -R` - рекурсивно показать содержимое поддиректорий
- `ll` - это общий псевдоним для ls -l (работает не во всех версиях linux)

`touch` - команда для создания файла.
- `touch file_name` - создаём файл с именем "file_name"
- `touch file_1 file_2 file_3` - создаём сразу несколько файлов

`mkdir` - команда для создания директории
- `mkdir dir` - создаём директории с именем "dir"
- `mkdir dir/dir2` - создаём директорию dir2 в директории dir если директори dir уже существует
 - `mkdir -p dir/dir2/dir3` - с ключём "-p" можно создавать поддиректории в директориях которые ещё не созданы. При этом будет создана вся цепочка поддиректорий до конечной.

`pwd` - показать текущую директорию  

`cd` - сменить текущую директорию
- `cd` - если ввести без аргументов, то попадём в домашнюю директорию текущего пользователя
- `cd ..` - переходим в каталог уровнем ниже
- `cd dir` - переходим в директорию "dir" из текущей директории
- `cd /home/dir` - переходим в ту же директорию "dir", но используя абсолютный путь

`rmdir` - команда которая позволяет удалить только пустую директорию  

`rm` - команда для удаления файлов. Эта команда без дополнительных ключей работает только с файлами.
- `rm file` - удалить файл с именем "file"
- `rm file*` - удалить все файлы, начинающиеся на "file".
- `rm *.txt` - удалить все файлы с расширением .txt
- `rm file?` - удалить все файлы с именем "file" при условии если у этого файла в конце имени ещё один любой символ
- `rm -r home/dir` - удалить все директории и файлы в директории dir. Всегда лучше указывать абсолютный путь.
- `rm -rf home/dir` - принудительное быстрое удаление директории dir со всем его содержимым без запросов на удаление.

`cp` - команда, позволяющая скопировать файлы и директории.
- `cp file dir/` - копируем файл с именем "file" в директорию dir/
- `cp -r dir dir2/` - копируем директорию dir в dir2/

`mv` - команда для перемещения файлов и директорий, а так же для их переименования.
- `mv file ./dir/` - перемещаем file в директорию dir
- `mv dir/ ./dir2/` - перемещаем директорию dir в ./dir2/ (ключи не нужны)
- `mv file file_new` - переименовываем файл "file" в "file_new"

`cat` - команда которая выводит содержимое файла на экран.
- `cat file` - выведет на экран содержимое файла "file"

`type` - команда, показывающая тип любой команды.
- `type ls` - покажет тип команды ls

`echo` - команда которая выводит на экран либо то, что мы ей пишем в качестве аргумента, либо содержимое переменной.
- `echo test` - выведет на экран текс "test"
- `echo $HISTSIZE` - выведет количество строк которые, сохраняются в истории команд
- `echo $PATH` - выведет содержимое переменной $PATH

`which` - команда которая показывает путь к бинарному файлу программы
- `which ls` - покажет путь к исполняемому файлу команды ls

`who` - команда которая показывает кто сейчас работает на этом сервере. Она выводит такую информацию как: кто подключен к серверу, к какому терминалу подключен, когда подключился и т.д.

`--help` - выводит краткую справку по командам.
- `ls --help` - выведет справку по команде ls

`man` - выводит расширенную справку по командам.
- `man ls` - вывведет расширенную справку по команде ls

## 3. Пользователи в Linux

### Идентификация пользователя UID
ОС можно разделить по следующим типам:
- Однопользовательские однозадачные (MSDOS)  

Это такие ОС в которых в один момент времени может исполняться одно программа и в этой ОС отсутствует какое-либо разграничение прав доступа пользователей.
- Однопользовательские многозадачные (Windows 95)  

В таких ОС с один момент времени есть возможность выполнять 2 и более программ, но в ней так же отсутствует разграничение прав доступа пользователей.
- Многопользовательские многозадачные (современные Windows, Linux, MAC OS и т.д.)  

В них можно одновременно выполнять несколько приложений и в них присутствует разграничение прав доступа до ресурсов компьютера.

Имя пользователя для ОС Linux - это строка с максимальной длиной 32 символа, которая не может содержать в себе символов ":" и символа новой строки. Так же, это всего лишь псевдоним.  
Для самой ОС важен не псевдоним, а другой тип идентефикации пользователя - UID (User identifier). Это числовое поле, которое может принимать значение от 0 до $2^{32} - 1$. Именно он определяет что это за пользователь и какими правами он обладает.  

В ОС Linux существует всего два типа пользователей. Это root (UID 0) и все остальные (UID не 0). Пользователь root - это пользователь который не имеет ни каких ограничений. Он может делать всё, что можно сделать технически. Он получает доступ до любых ресурсов, удалять любые файлы, редактировать любые файлы и т.д. Ко всем остальным пользователям применяются какие-то ограничения.  

Все остальные пользователи на которых накладываются ограничения ОС разделяются на 2 типа:
- Служебные  

Под обычных пользователей обычно выделяется свой диапазон UIDов. В некоторых ОС это от 1 до 500, в других ОС это от 1 до 1000. Служебные пользоатели это пользователи от которых работают те или иные приложения именуемые в ОС Демонами. Демон - это комп программа в системах класса UNIХ, запускаемая самой системой и работающая в фоновом режиме без прямого взаимодействия с пользователем.
- Обычные  

Это обычные пользователи-люди. Они имеют свои домашние директории и свои права доступа.

### Где хранятся информация о пользователях и группах в ОС?
#### **/etc/passwd**

В этом файле хранится информация о пользователях ОС Linux. Строка из этого файла состоит из нескольких полей разделённых двоеточием.  

Типичная строка из файла /etc/passwd выглядит так:  

`root:x:0:0:root:/root:/bin/bash`  

 Первое поле `root` - это имя пользователя.  
 Второе поле это `x` - когда-то давно в этом месте хранили пароль пользователей. Сейчас пароли, вернее хэши паролей, хранятся в специальном файле. Просто это поле убирать не стали.  
 Третье поле `0` - это UID.  
 Четвёртое поле `0` - это GID (Group identifier). Как правило, если мы создаём нового пользователя, то его группа по умолчанию равна имени его логина.  
 Пятое поле `root` - это просто комментарий.  
 Шестое поле `/root` - это домашний каталог пользователя.  
 Седьмое поле `/bin/bash` - это командная оболочка пользователя.  

#### **/etc/group**

В этом файле хранится специальная информация о группах. Формат строки из этого файла проще чем из фаила `/etc/passwd`. 

Типичная строка из файла `/etc/group` выглядит так:  

`wheel:x:10:user`  

`wheel` - это имя группы  
`10` - это информация о гиде группы  
`user` - это имя пользователя  

Получить информацию о том куда входит пользователь можно командой `id`.  

`id user` - выведет uid, git и другую информацию  

Чтобы изменить вхождение пользователя в ту или иную группу можно использовать утилиту `usermod`:

`sudo usermode -aG mail user` - эта команда добавит пользователя "user" в группу "mail".

### Организация хранения паролей пользователей.

Информация о паролях пользователей хранится в специальном файле `/etc/shadow`. То что находится в этом файле является работой хэш-функции, а не сами пароли пользователей.  
`Хэш-функция` - это функция которая не имеет обратного преобразования. Простейшим примером такой функции может являться функция $x^2 = y$. Если мы знаем $y$ (результат работы функции), а $x$ - не известно, то мы никогда не узнаем чему был равен $x$ (2 или же -2).  
`Аутентификация пользователя` - это проверка наличия пользователя в системе. Этот процесс происходит следующим образом: системе передаётся логин пользователя и строчка с паролем. Затем система передаёт пароль хэш-функции и результат работы этой функции сравнивает с тем хэшем который есть в файле `etc/shadow`. Если хэши совпали, то дальше происходит авторизация.  
`Авторизация пользователя` - это когда система проверяет есть ли у пользователя права доступа к серверу. Это проверка наличия прав до доступа к ресурсам.  

### Права на файлы в Linux.

В ОС Linux есть 3 типа прав.
- Права на чтение (`r` - read)
- Права на запись (`w` - write)
- Права на исполнение (`x` - execute) 

<image src="./images/rights.jpg" alt="rights">

Помимо этого в ОС Linux есть три типа доступа:
- Доступ для владельца файла (user)
- Для группы владельца файла (group)
- И для всех остальных (other)

<image src="./images/other_rights.jpg" alt="other_rights">

Существует и другой способ указать права доступа - с помощью восьмеричного представления. Вес каждого идентификатора прав следующий:

<image src="./images/digital_rights.jpg" alt="digital_rights">

Числовые обозначения прав пользователей можно посчитать или определить по таблице:

<image src="./images/rights_table.jpg" alt="rights_table">

Так как у нас права доступа разделяются на 3 категории (владелец, группа, остальные), то применяется трехзначное обозначение. Например, права доступа для абсолютно всех будут выглядеть как `-rwxrwxrwx`, а в числовом значении как `777`.

Для того, чтобы сменить права пользователя в ОС Linux есть такая команда как `chmod`. Примеры использования:
- `chmod u-w file` - убрать права на запись в file для пользователя.
- `chmod g-w file` - убрать права на запись в file для группы.
- `chmod o+w file` - добавить права на запись в file для остальных.
- `chmod u+rwx,g-x+rw,o-rwx` - добавить полные права для user, группе убрать права на выполнение и добавить на чтение и запись, а всем остальным убрать все права.

Команда `chmod` может так же работать и с директориями:
- `chmod a+rwx dir/` - можно написать `a` - all и права применятся сразу ко всем ктегориям пользователей. Эта команда изменяет права на директорию, но не на сожержимое директории. Чтобы изменить права и на содержимое нужно применить ключ `-R`. 
- `chmod -R a+rwx dir/` - меняет права так же и на содержимое директории

Если на директории нет права на исполнение `x`, то мы не сможем туда зайти. Так же нельзя будет увидеть информацию о файлах директории, а именя файлов можно.  
Если на директории нет права на чтение `r`, то мы не сможем прочитать имена файлов в директории, но зайти мы туда сможем. Если мы будем знать имена файлов в директории в явном виде, то мы сможем с ними работать. Так же можно прочитать содержимое директории которая находится в директории без доступа на чтение, например `ls -l ./dir/dir2`.

### Файловые системы и inode.

`Файл` - это именованная область данных на диске. Файлы на дисках хранятся в виде `блоков` (минимальная единица хранения информации на диске - `4Кб` или `4097 байт`).
В Linux достаточно часто используемая файловая система это `ext4`. Данная файловая система содержит в себе специальную информацию (специальную структуру данных), которая называется `inode` (index node). В inode записывается информация о занятых блоках на диске, правах доступа для файлов. Вывести информацию из inode файла можно с помощью команды stat:

- `stat file` - выведет информацию из inode файла file

Количество inode в ФС типа ext ограничено, оно создаётся в момент создания файловой системы ext, после создания их количество изменить нельзя. Как следствие мы не сможем создать файлов больше чем inode в файловой системе ext.
inode идентифицируются по номеру. Чтобы увидеть номер inode можно написать

- `ls -li` - в первом столбце будут номера inode

Для того, чтобы увидеть общее количество inode в ФС можно воспользоваться утилитой `df`:

- `df -i` - покажет информацию об inode в ФС

`Каталог` - это специальный тип файлов который хранит в себе имена других файлов и каталогов. Это обычный файл в котором есть соответствие между именем файла и номером inode. А удаление файла это просто удаление его имени из каталога (отвязка имени и inode). Так же каталог является неотъемлемой частью ФС. Если создать ФС без каталогов, то негде будет хранить имена файлов и каталогов.  
Таким образом, доступ на выполнение на каталоге позволяет прочитать inode файлов. Именно поэтому, если убрать доступ на выполнение на каталоге, то можно увидеть имя файла, но не информацию о файле.  
Таким же образом, если запретить доступ на чтение на каталоге, то невозможно будет прочитать имя файла в каталоге, но доступ до inode не будет запрещён. Поэтому если знать точное имя файла в каталоге у которого запрет на чтение, то можно прочитать информацию из inode этого файла.

### HardLink и SoftLink.

`HardLink` - это просто имя файла (жёсткая ссылка). При выводе команды `ls -l` второй столбец показывает количество HardLink у данного файла.
 Если создать ещё один HardLink на файл, то оба имени файла будут ссылаться на одну и туже inode. Т.е. HardLink это щё одна запись в каталоге о файле. Например `ln file3 file3_hl`.

<image src="./images/hardlink.jpg" alt="hardlink">

Как следствие, файл существует до тех пор, пока существует хотя бы один HardLink на него. Количество HardLink на файле хранится в inode. Если зменить права хотя бы на один HardLink, то на всех HardLink права тоже поменяются. Понятие главного HardLink не существует, все HardLink равны между собой. 
HardLink имеют некоторые особенности:
- HardLink нельзя содавать на каталоге, но они существуют в рамках ФС (это HardLink на каталог "." и каталог "..")
- HardLink возможно создавать в пределах одного диска, одной ФС, т.к. inode уникальны в пределах одной ФС

`SoftLink` - это аналоги ярлыков Windows. Это просто файлы которые содержат в себе ссылку на другой файл.  
Создать SoftLink можно например командой `ln -s file3_hl file3_sl`

<image src="./images/softlink.jpg" alt="softlink">

Файл `file3_sl` является SoftLink на `file3_hl`. `file3_sl` имеет права `777` имеет признак `l` и после обращения к нему в силу будут вступать права файла `file3_hl`.

**Выводы:**
- HardLink не занимают inode, т.к. это не новые файлы, а только ещё одно имя уже существующего файла
- SoftLink inode занимают, т.к. это новый файл который ссылается на существующий файл

## 4. Работа с файлами

`grep (global regular expression print)` - это утилита, которая фильтрует и выводит информацию на экран. Примеры использования:
- `grep "Failed" ./log` - выводит все строки из файла ./log в которых содержится слово "Failed".
- `grep -i "failed" ./log` - инорирует регистр.

`head` - это утилита, которая выводит несколько первых строк файла.
- `head ./log` - выведет первые 10 строк файла ./log
- `head -3 ./log` - выведет первые 3 строки фала
- `head -n 3 ./log` - то же самое

`tail` - это утилита, которая выводит на экран несколько последних строк файла.
- `tail ./log` - выведет последние 10 строк файла ./log
- `tail 3 ./log` - выведет последние 3 строк файла ./log
- `tail -n 3 ./log` - то же самое
- `sudo tail -f /var/log/secure` - выведет инфо из файла /var/log/secure и не прекратит свою работу, а будет постоянно выводить информацию в реальном времени, поступающую в данный файл

`more` - утилита, которая выводит файл на экран и позволяет прокручивать содержимое этого файла.
- `more ./log` - выводит на экран файл ./log. Пробел - листаем файл постранично, Enter - листаем построчно. Чтобы выйти нужно нажать "q"

`less` - это более удобная утилита, которая позволяет просматривать файл.
- `less ./log` - выводит на экран файл ./log. Работают стрелки "вверх", "вниз", "PgUp", "PgDn. Так же работает поиск по документу - нажимаем "/" и вводим то, что хотим найти.