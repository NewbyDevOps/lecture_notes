# <p style="text-align: center">Потоки, логические команды, процессы, сеть</p>

<image src="./images/linux.png" alt="linux">

## 1. Работа с потоками STDIN, STDOUT, STDERR

В Unix системах униферсальный интерфейс взаимодействия между ПО это потоки текстовых данных. Каждая программа в ОС Linux имеет 3 стандартных потока данных.

- STDIN - стандартный поток ввода
- STDOUT - стандартный поток вывода
- STDERR - стандартный поток ошибок

<image src="./images/streams.jpg" alt="streams">

Любая запущенная программа должна работать с какими-то аргументами. Эти аргументы она получает на свой `стандартный поток ввода`. Как правило стандартный поток ввода подключён к клавиатуре. Так же большинство программ умеет принимать стандартный поток данных из других программ.  
После того как программа выполнил необходимые действия, она должна сообщить о результате. Вывод информации осуществляется по двум потокам:
`стандартный поток вывода` - в него попадает информация которая была корректно обработана программой и `стандартный поток ошибок` - туда выводятся ошибки которые допустила программа в процессе своей работы. По умолчанию оба этих потока `STDOUT` и `STDERR` перенаправлены в устройство "терминал", которое подключено к нашему дисплею. 
Эти потоки мы можем перенапралять. Перенаправлять их в файл или в другую программу. Именно разделение этих потоков даёт такую гибкость и удобство работы с ними.  
Каждый поток имеет свой номер (дескрипторы файлов потока):

- STDIN - 0
- STDOUT - 1
- STDERR - 2

Для того, чтобы перенаправить `стандартный поток вывода` используем следующую команду:

- `ls -l > stdout` - на экране ничего не отобразится, а вся информация будет перенаправлена в файл stdout. В этом файле будет прописано содержимое текущей директории. При этом символ `>` без обозначения потока будет работать только с перым потоком. Т.е. `>` и `1>` это одно и то же.

Чтобы перенаправить `стандартный поток ошибок` в файл используем следующую команду:

- `ls -l afdsfs 2> stderr` - запишет в файл stderr ошибку от программы ls если файла afdsfs не существует.

Если написать команду:

- `ls -l adsad 2> stderr 1> stdout` - то мы получим 2 файла, stderr - с ошибками от команды ls, stdout - с выводом команды ls.

Команды с символом `>` перезаписывают файлы. Если необходимо дописать в файлы, то необходимо использовать символы `>>`:

- `ls -l adsad 2>> stderr 1>> stdout`

### Порядок выполнения команд в bash.

Порядок выполнения команды `ls -l > stdout` следующий:

- Bash начинает интерпретировать эту команду справа налево.
- Bash проверяет, существует ли файл stdout. Если не существует, то файл будет создан. Когда файл будет создан, он будет пустой. Кстати, это ещё один способ создать файл: `> file`.
- Если файл существует, то будет интерпретирован значёк `>`. При этом существующий файл будет обнулён.
- После этого будет выполнена команда `ls -l`.

При выполнении команды `ls -l > stdout` есть ньюанс. Если при её выполнении файла `stdout` не существовало, то размер файла `stdout` внутри самого файла `stdout` будет равен 0. Это произошло по следующийм причинам:

- В момент создания файла `stdout` его содержимое не существовало и его размер был равен 0. 
- Затем была выполнена команда `ls -l`, которая и показала нам этот созданный файл `stdout` с размером 0. Именно эта информация была перенаправлена в файл `stdout`.
- И только после всего этого мы увидели файл `stdout` в директории который занимает определённое количество байт.

Учитывая такое поведение bash, можно выполнить команду `ls -l file_test > file_test` и даже при условии, что файла `file_test` не существовало, она отработает корректно. При этом команда `ls -l file_test`, при условии отсутствия файла `file_test`, выдаст ошибку.  
Разберём команду `tail -n 50 log > log`. Т.е. мы хотим вывести в существующий файл `log` последние 50 строк из того же файла `log`. Эта команда не приведёт к желаему результату, т.к. в процессе выполнения такой конструкции файл `log` обнулится и в итоге результирующий файл `log` будет 0 байт.

### Перенаправление в STDIN другой команды.
Представим, что есть файл `stdout` в который записаны данные после выполнения команды `ls -l > stdout`. При выполнении команды `cat stdout` на экран будет выведено содержимое файла `stdout`. Теперь выполним команду с перенаправлением в другую команду. Например `cat stdout | grep ^-` Эта команда содержит следующие элементы и работает следующим образом:

- `|` - pipe, конструкция для перенаправления STDOUT одной команды, на STDIN другой команды.
- `grep ^-` - фильтруем по символу начала строки `^`, который будет начинаться с чёрточки "-" (файлы в Linux это то, что начинается с чёрточки).
- В итоге мы перенаправляем STDOUT команды cat, на STDIN команды grep.
- Такой же результат можно получить, использовав конструкцию `grep ^- stdout`.

Если мы хотим сделать ещё фильтр, то можно написать, например, следующее:

- `cat stdout | grep ^- | grep rwx` - выведет все файлы, в правах которых есть `rwx`.
- `cat stdout | grep ^- | grep rwx | grep 2$` - то же самое, только теперь ещё фильтруем по файлам, которые кончаются на 2. 

При этом, количество таких передач, перенаправлений не ограничено (ограничено только размером оперативной памяти). Но не все команды могут корректно принимать информацию на свой поток ввода.   
Как быть, если мы хотим, например, видеть перенаправленные потоки и на экране и одновременно перенаправить их в файл? Для этого существует команда `tee`. Эта программа получает на свой STDIN данные и перенаправляет один поток STDOUT на экран, а другой STDOUT в файл.

- `ls -l | tee file` - выводит данные и на экран и пишет в файл. При этом команда `tee` перезапишет файл `file`.
- `ls -l | tee -a file` - допишет данные в `file`, а не перезапишет его.

### Потоки и указатели.
Указатели нужны для перенаправления потоков по адресу к которому направлен тот или иной поток. Например, если мы хотим перенаправить в один файл или программу и STDOUT и STDERR, то необходимо указывать указатели (`&`).

- `ls -l asdf ./ 1> file 2>&1` - перенаправляем поток 1 (`STDOUT`) в файл, а поток 2 (`STDERR`) перенаправляем туда же куда был перенаправлен поток 1.

Если мы используем 2 и более перенаправлений потоков, то в этом случае bash начинает интерпретировать перенаправление слева направо. Т.е. в конструкции `ls -l asdf ./ 1> file 2>&1` будет сначала исполнена правая часть, но слева направо. Сначала поток 1 будет перенаправлен в файл `1> file`, затем поток 2 будет перенаправлен туда же, куда и поток 1 `2>&1`. Символ `&` означает `перенаправление по адресу`.  
То же самое можно делать на перенаправление STDIN другой команды:

- `ls -l asdf ./ 2&1 | grep file` - перенаправляем 2й поток туда же, куда будет перенаправлен 1й, а 1й мы перенаправляем в `grep`. Т.е. оба потока перенаправлены на стандартный поток ввода команды `grep`. При выполнении этой команды сначала интерпретируется значёк `|`.

В данной конструкции следующая последовательность выполнения:

- Сначала перенаправить поток 1 на поток ввода команды grep.
- Затем, поток 2 перенаправить туда же куда смотрит поток 1.

Рассмотрим следующую команду:

- `ls -l asdf ./ 2>&1 1> /dev/null | grep asd` - это перенаправление на стандартный поток ввода одной программы исключительно стандартного потока ошибок другой. Здесь мы 2й поток перенаправляем туда же куда перенаправляем 1й. 1й поток мы перенаправляем в /dev/null (специальное устройство, которое подавляет вывод). И далее мы перенаправляем это в команду `grep`. 

Расммотрим эту конструкцию более подробно. В начале интерпретируется значёк `|` и мы получаем перенаправление потока 1 (STDOUT команды ls), на поток 0 (STDIN команды grep). Дальше bash начинает интерпретировать команды ввода-вывода слева направо: сначала поток 2 перенаправляется туда, куда смотрит поток 1 (`2>&1`), а поток 1 уже смотрит на STDIN команды grep. После этого мы указываем перенаправить поток 1 в устройство `/dev/null`. После этого поток 1 отвязывается от STDIN команды grep и перенаправляется в `/dev/null`, но при этом поток 2 ни куда не девается. 

## 2. И, ИЛИ, НЕ ИМЕЕТ ЗНАЧЕНИЯ.

### Код возврата команды.

Каждая программа возвращает свой код возврата. Чтобы посмотреть кодвозврата последней выполненной команды нужно прописать команду:

- `echo $?` - где, `$` - это обозначение переменной, а `?` - это код возврата последней выполненной команды.

### Логическая конструкция "И" при выполнении команд

Логическое "И" при выполнении команд подразумевает, что если выполнится первая команда, то выполнится и вторая команда. Логическое "И" в bash обозначается двойным символом амперсанта `&&`.  
Пример:

- `ls -l && echo OK` - сначала корректно отработает команда `ls -l`, затем команда `echo OK`. Если бы команда `ls -l` отработала бы с ошибкой, то следующая команда не будет выполнена.

### Логическая конструкция "ИЛИ" при выполнении команд

Логическое "ИЛИ" при выполнении команд подразумевает, что команды в цепочке будут выполняться до тех пор пока хотя бы одна из них не выполнится корректно. Логическое "ИЛИ" обозначается двумя вертикальными чёрточками `||`.  
Пример:

- `ls -l || echo ERR` - здесь, если не будет выполнена команда `ls -l`, то выполнится команда `echo ERR`.

### Оператор "Не имеет значения"

Оператор "Не имеет значения" при выполнении цепочки команд будет означать, что последующие команды будут выполнены в любом случае. Этот оператор обозначается символом `;`  
Пример:

- `ls -l ; echo No OK` - при любом исходе выполнения команды `ls -l`, будет выполнена следующая команда `echo No OK`.

Этот оператор интересен, когда мы не хотим писать несколько команд последовательно, а хотим написать все команды в одну строчку.

### Итоги

- `&&` - логическое "И"
- `||` - логическое "ИЛИ"
- `;` - логическое "НЕ ИМЕЕТ ЗНАЧЕНИЯ"
- Логические операторы работают на основании кода возврата программы.

## 3. Монтирование.

Диски в Linux находятся в специальном каталоге /dev. В этом специальном каталоке есть перечень всех наших дисковых устройств. Если мы видим отображение дисков состоящее из букв, то это `физические диски` (`/dev/sda, /dev/sdb...`). Если в конце обозначения дисков есть цифры, то это `логические диски` (`/dev/sda1, /dev/sda2...`), т.е. диски которые представляют собой логическую структуру на физическом носителе.  
С этими дисками мы можем работать как с реальными дисками посредством специальной виртуальной файловой системы (VFS). Вообще, всё взаимодействие с дисковыми устройствами в Linux реализовано с помощью VFS. Т.е. это уровень абстракции, который позволяет унифицировать доступ до файлов. Когда мы используем VFS, то мы не задумываемся знает ли наша ОС ту или иную файловую систему, мы просто работаем с VFS, а VFS уже посредством `драйвера файловой` системы обеспечиват доступ к физической файловой системе. Связывание фиртуальной ФС с виртуальной ФС называется `монтирование`.  

<image src="./images/vfs.jpg" alt="vfs">

VFS имеет следующие функции и свойства:

- Обеспечивает единообразный доступ клиентских приложений к различным типам ФС.
- Она является уровнем абстракции поверх конкретной реализации файловой системы.
- Она является программным интерфейсом между ядром и драйвером конкретной ФС.

Для того, чтобы начать работать с диском как с привычным нам устройством как в Windows, нам нужно подмонтировать диск к какому-нибудь каталогу. Т.е. сделать `связку каталога` и `файла блочного устройства`. А внутри ядра произойдёт связывание виртуальной ФС (посредством драйвера) с реальной ФС.  
После того, как запускается ядро ОС Linux происходит первичное монтирование корневой ФС. Все точки монтирования, которые будут примонтированы при запуске ОС Linux хранятся в специальном файле, который хранится в каталоге `/etc/fstab`  
Чтобы посмотреть какие диски подмонтированы в нашу ОС можно воспользоваться слудующими командами 

- `df -h` - покажет какие блочные устройства куда подмонтированы. Это достаточно простой и не всегда информативный способ. В вывод этой команды не будут попадать варианты монтирования каталогов с опцией bind.

- `mount` - выведет более полную информацию о том, что и куда подмонтировано. Вся информация, которая выводится в процессе работы этой програмы хранится в `/proc/self/mounts`
 
Для процедуры монтирования и отмонтирования используются команды `mount` и `umount`:

- `sudo mount /dev/sda /mnt/` - `/dev/sda` - что монтируем, `/mnt/` - куда монтируем.
- `sudo umount /mnt/` - вариант отмонтирования с указанием того, ОТКУДА отмонтируем.
- `sudo umount /dev/sda` - вариант отмонтирования с указанием того, ЧТО отмонтируем.

### Итоги

- `Монтирование` - "связка" файла дискового устройства с каталогом.
- `VFS` - Virtual File System
- `/proc/self/moutns` - файл, содержащий информацию о точках монтирования.
- `/etc/fstab` - файл, описывающий точки монтирования при старте ОС.

## 4. Установка ПО

В ОС Linux есть пакетный менеджер который отвечает за локальную установку прграммного обеспечения. Он же строит базы данных в которых есть информация о том, какие пакеты у нас установлены и какой версии. И есть надстройка над этим пакетным менеджером которая работает с репозиториями.  
Пакетный менеджер в Linux Fedora называется `rpm`. А надстройка называется `yum`. В последних версиях Fedora yum был заменён модернизированным менеджером `dnf`.  

Пример установки ПО с помощью `yum`:  

`sudo yum install httpd` - установит пакет httpd и зависимости.  

Чтобы посмотреть что установилось нужно ввести команду:

`rpm -ql httpd` - покажет все файлы которые установлены при установке пакта httpd.

Отфильтруем все найденные файлы по имени каталога bin:

`rpm -ql httpd | grep bin` - выведет все названия с bin.

Исполняемый файл находится в директории /usr/sbin/httpd.

### Поиск пакета по файлу

Для того, что бы найти пакет по имени файла в этом пакете нужно использовать утилиту `yum` с ключём `provides`.

`yum provides *ls` - найдёт ls во всех пакетах, во всех репозиториях.
`yum provides *ls` - немного сузит область поиска, но вывод всё равно будет большой.  
Можно сравнить вывод, добавив в команду `| wc -l` - это счётчик строк.

Если отфильтровать по слову bin, то на выводе будет всего несколько результатов. 

`yum provides | grep bin` - выведет все названия каталогов с bin. Нам нужен каталог `usr/bin/ls`.
Так же можно найти программу ls используя команду `which ls`.

### Список установленных пакетов

Для того, что бы увидеть, что установленно на нашей ОС можно выполнить следующую команду:

`rpm -qa` - выведет весь список установленных пакетов. Чтобы посчитать можно воспользоваться подсчётом строк через `| wc -l`. А через `| grep` можно найти нужный пакет.

Если мы хоти удалить пакет, то можно пойти двумя путями:

1. Использовать `rpm`. Тогда мы локально удалим пакет.
2. Либо использовать `yum`.

Чтобы удалить с помощью `yum` нужно ввести команду:

`sudo yum remove httpd` - удалит пакет httpd. **Но зависимости пакета не удалятся.**

Чтобы удалить с помощью `rpm` нужно ввести команду:

`sudo rpm -e httpd` - удалит пакет httpd. **Но зависимости пакета не удалятся.**

**Итоги**

- `rpm` - работа с пакетами
- `yum` - работа с репозиторием
- для просмотра информации об установленных пакетах нужно использовать `rpm`
- для поиска нужного пакета в репозитории нужно использовать `yum`

