# <p style="text-align: center">Потоки, логические команды, процессы, сеть</p>

<image src="./images/linux.png" alt="linux">

## 1. Работа с потоками STDIN, STDOUT, STDERR

В Unix системах униферсальный интерфейс взаимодействия между ПО это потоки текстовых данных. Каждая программа в ОС Linux имеет 3 стандартных потока данных.

- STDIN - стандартный поток ввода
- STDOUT - стандартный поток вывода
- STDERR - стандартный поток ошибок

<image src="./images/streams.jpg" alt="streams">

Любая запущенная программа должна работать с какими-то аргументами. Эти аргументы она получает на свой `стандартный поток ввода`. Как правило стандартный поток ввода подключён к клавиатуре. Так же большинство программ умеет принимать стандартный поток данных из других программ.  
После того как программа выполнил необходимые действия, она должна сообщить о результате. Вывод информации осуществляется по двум потокам:
`стандартный поток вывода` - в него попадает информация которая была корректно обработана программой и `стандартный поток ошибок` - туда выводятся ошибки которые допустила программа в процессе своей работы. По умолчанию оба этих потока `STDOUT` и `STDERR` перенаправлены в устройство "терминал", которое подключено к нашему дисплею. 
Эти потоки мы можем перенапралять. Перенаправлять их в файл или в другую программу. Именно разделение этих потоков даёт такую гибкость и удобство работы с ними.  
Каждый поток имеет свой номер (дескрипторы файлов потока):

- STDIN - 0
- STDOUT - 1
- STDERR - 2

Для того, чтобы перенаправить `стандартный поток вывода` используем следующую команду:

- `ls -l > stdout` - на экране ничего не отобразится, а вся информация будет перенаправлена в файл stdout. В этом файле будет прописано содержимое текущей директории. При этом символ `>` без обозначения потока будет работать только с перым потоком. Т.е. `>` и `1>` это одно и то же.

Чтобы перенаправить `стандартный поток ошибок` в файл используем следующую команду:

- `ls -l afdsfs 2> stderr` - запишет в файл stderr ошибку от программы ls если файла afdsfs не существует.

Если написать команду:

- `ls -l adsad 2> stderr 1> stdout` - то мы получим 2 файла, stderr - с ошибками от команды ls, stdout - с выводом команды ls.

Команды с символом `>` перезаписывают файлы. Если необходимо дописать в файлы, то необходимо использовать символы `>>`:

- `ls -l adsad 2>> stderr 1>> stdout`

### Порядок выполнения команд в bash.

Порядок выполнения команды `ls -l > stdout` следующий:

- Bash начинает интерпретировать эту команду справа налево.
- Bash проверяет, существует ли файл stdout. Если не существует, то файл будет создан. Когда файл будет создан, он будет пустой. Кстати, это ещё один способ создать файл: `> file`.
- Если файл существует, то будет интерпретирован значёк `>`. При этом существующий файл будет обнулён.
- После этого будет выполнена команда `ls -l`.

При выполнении команды `ls -l > stdout` есть ньюанс. Если при её выполнении файла `stdout` не существовало, то размер файла `stdout` внутри самого файла `stdout` будет равен 0. Это произошло по следующийм причинам:

- В момент создания файла `stdout` его содержимое не существовало и его размер был равен 0. 
- Затем была выполнена команда `ls -l`, которая и показала нам этот созданный файл `stdout` с размером 0. Именно эта информация была перенаправлена в файл `stdout`.
- И только после всего этого мы увидели файл `stdout` в директории который занимает определённое количество байт.

Учитывая такое поведение bash, можно выполнить команду `ls -l file_test > file_test` и даже при условии, что файла `file_test` не существовало, она отработает корректно. При этом команда `ls -l file_test`, при условии отсутствия файла `file_test`, выдаст ошибку.  
Разберём команду `tail -n 50 log > log`. Т.е. мы хотим вывести в существующий файл `log` последние 50 строк из того же файла `log`. Эта команда не приведёт к желаему результату, т.к. в процессе выполнения такой конструкции файл `log` обнулится и в итоге результирующий файл `log` будет 0 байт.

### Перенаправление в STDIN другой команды.
Представим, что есть файл `stdout` в который записаны данные после выполнения команды `ls -l > stdout`. При выполнении команды `cat stdout` на экран будет выведено содержимое файла `stdout`. Теперь выполним команду с перенаправлением в другую команду. Например `cat stdout | grep ^-` Эта команда содержит следующие элементы и работает следующим образом:

- `|` - pipe, конструкция для перенаправления STDOUT одной команды, на STDIN другой команды.
- `grep ^-` - фильтруем по символу начала строки `^`, который будет начинаться с чёрточки "-" (файлы в Linux это то, что начинается с чёрточки).
- В итоге мы перенаправляем STDOUT команды cat, на STDIN команды grep.
- Такой же результат можно получить, использовав конструкцию `grep ^- stdout`.

Если мы хотим сделать ещё фильтр, то можно написать, например, следующее:

- `cat stdout | grep ^- | grep rwx` - выведет все файлы, в правах которых есть `rwx`.
- `cat stdout | grep ^- | grep rwx | grep 2$` - то же самое, только теперь ещё фильтруем по файлам, которые кончаются на 2. 

При этом, количество таких передач, перенаправлений не ограничено (ограничено только размером оперативной памяти). Но не все команды могут корректно принимать информацию на свой поток ввода.   
Как быть, если мы хотим, например, видеть перенаправленные потоки и на экране и одновременно перенаправить их в файл? Для этого существует команда `tee`. Эта программа получает на свой STDIN данные и перенаправляет один поток STDOUT на экран, а другой STDOUT в файл.

- `ls -l | tee file` - выводит данные и на экран и пишет в файл. При этом команда `tee` перезапишет файл `file`.
- `ls -l | tee -a file` - допишет данные в `file`, а не перезапишет его.

### Потоки и указатели.
Указатели нужны для перенаправления потоков по адресу к которому направлен тот или иной поток. Например, если мы хотим перенаправить в один файл или программу и STDOUT и STDERR, то необходимо указывать указатели (`&`).

- `ls -l asdf ./ 1> file 2>&1` - перенаправляем поток 1 (`STDOUT`) в файл, а поток 2 (`STDERR`) перенаправляем туда же куда был перенаправлен поток 1.

Если мы используем 2 и более перенаправлений потоков, то в этом случае bash начинает интерпретировать перенаправление слева направо. Т.е. в конструкции `ls -l asdf ./ 1> file 2>&1` будет сначала исполнена правая часть, но слева направо. Сначала поток 1 будет перенаправлен в файл `1> file`, затем поток 2 будет перенаправлен туда же, куда и поток 1 `2>&1`. Символ `&` означает `перенаправление по адресу`.  
То же самое можно делать на перенаправление STDIN другой команды:

- `ls -l asdf ./ 2&1 | grep file` - перенаправляем 2й поток туда же, куда будет перенаправлен 1й, а 1й мы перенаправляем в `grep`. Т.е. оба потока перенаправлены на стандартный поток ввода команды `grep`. При выполнении этой команды сначала интерпретируется значёк `|`.

В данной конструкции следующая последовательность выполнения:

- Сначала перенаправить поток 1 на поток ввода команды grep.
- Затем, поток 2 перенаправить туда же куда смотрит поток 1.

Рассмотрим следующую команду:

- `ls -l asdf ./ 2>&1 1> /dev/null | grep asd` - это перенаправление на стандартный поток ввода одной программы исключительно стандартного потока ошибок другой. Здесь мы 2й поток перенаправляем туда же куда перенаправляем 1й. 1й поток мы перенаправляем в /dev/null (специальное устройство, которое подавляет вывод). И далее мы перенаправляем это в команду `grep`. 

Расммотрим эту конструкцию более подробно. В начале интерпретируется значёк `|` и мы получаем перенаправление потока 1 (STDOUT команды ls), на поток 0 (STDIN команды grep). Дальше bash начинает интерпретировать команды ввода-вывода слева направо: сначала поток 2 перенаправляется туда, куда смотрит поток 1 (`2>&1`), а поток 1 уже смотрит на STDIN команды grep. После этого мы указываем перенаправить поток 1 в устройство `/dev/null`. После этого поток 1 отвязывается от STDIN команды grep и перенаправляется в `/dev/null`, но при этом поток 2 ни куда не девается. 

## 2. И, ИЛИ, НЕ ИМЕЕТ ЗНАЧЕНИЯ.

### Код возврата команды.

Каждая программа возвращает свой код возврата. Чтобы посмотреть кодвозврата последней выполненной команды нужно прописать команду:

- `echo $?` - где, `$` - это обозначение переменной, а `?` - это код возврата последней выполненной команды.

### Логическая конструкция "И" при выполнении команд

Логическое "И" при выполнении команд подразумевает, что если выполнится первая команда, то выполнится и вторая команда. Логическое "И" в bash обозначается двойным символом амперсанта `&&`.  
Пример:

- `ls -l && echo OK` - сначала корректно отработает команда `ls -l`, затем команда `echo OK`. Если бы команда `ls -l` отработала бы с ошибкой, то следующая команда не будет выполнена.

### Логическая конструкция "ИЛИ" при выполнении команд

Логическое "ИЛИ" при выполнении команд подразумевает, что команды в цепочке будут выполняться до тех пор пока хотя бы одна из них не выполнится корректно. Логическое "ИЛИ" обозначается двумя вертикальными чёрточками `||`.  
Пример:

- `ls -l || echo ERR` - здесь, если не будет выполнена команда `ls -l`, то выполнится команда `echo ERR`.

### Оператор "Не имеет значения"

Оператор "Не имеет значения" при выполнении цепочки команд будет означать, что последующие команды будут выполнены в любом случае. Этот оператор обозначается символом `;`  
Пример:

- `ls -l ; echo No OK` - при любом исходе выполнения команды `ls -l`, будет выполнена следующая команда `echo No OK`.

Этот оператор интересен, когда мы не хотим писать несколько команд последовательно, а хотим написать все команды в одну строчку.

### Итоги

- `&&` - логическое "И"
- `||` - логическое "ИЛИ"
- `;` - логическое "НЕ ИМЕЕТ ЗНАЧЕНИЯ"
- Логические операторы работают на основании кода возврата программы.

## 3. Монтирование.

Диски в Linux находятся в специальном каталоге /dev. В этом специальном каталоке есть перечень всех наших дисковых устройств. Если мы видим отображение дисков состоящее из букв, то это `физические диски` (`/dev/sda, /dev/sdb...`). Если в конце обозначения дисков есть цифры, то это `логические диски` (`/dev/sda1, /dev/sda2...`), т.е. диски которые представляют собой логическую структуру на физическом носителе.  
С этими дисками мы можем работать как с реальными дисками посредством специальной виртуальной файловой системы (VFS). Вообще, всё взаимодействие с дисковыми устройствами в Linux реализовано с помощью VFS. Т.е. это уровень абстракции, который позволяет унифицировать доступ до файлов. Когда мы используем VFS, то мы не задумываемся знает ли наша ОС ту или иную файловую систему, мы просто работаем с VFS, а VFS уже посредством `драйвера файловой` системы обеспечиват доступ к физической файловой системе. Связывание фиртуальной ФС с виртуальной ФС называется `монтирование`.  

<image src="./images/vfs.jpg" alt="vfs">

VFS имеет следующие функции и свойства:

- Обеспечивает единообразный доступ клиентских приложений к различным типам ФС.
- Она является уровнем абстракции поверх конкретной реализации файловой системы.
- Она является программным интерфейсом между ядром и драйвером конкретной ФС.

Для того, чтобы начать работать с диском как с привычным нам устройством как в Windows, нам нужно подмонтировать диск к какому-нибудь каталогу. Т.е. сделать `связку каталога` и `файла блочного устройства`. А внутри ядра произойдёт связывание виртуальной ФС (посредством драйвера) с реальной ФС.  
После того, как запускается ядро ОС Linux происходит первичное монтирование корневой ФС. Все точки монтирования, которые будут примонтированы при запуске ОС Linux хранятся в специальном файле, который хранится в каталоге `/etc/fstab`  
Чтобы посмотреть какие диски подмонтированы в нашу ОС можно воспользоваться слудующими командами 

- `df -h` - покажет какие блочные устройства куда подмонтированы. Это достаточно простой и не всегда информативный способ. В вывод этой команды не будут попадать варианты монтирования каталогов с опцией bind.

- `mount` - выведет более полную информацию о том, что и куда подмонтировано. Вся информация, которая выводится в процессе работы этой програмы хранится в `/proc/self/mounts`
 
Для процедуры монтирования и отмонтирования используются команды `mount` и `umount`:

- `sudo mount /dev/sda /mnt/` - `/dev/sda` - что монтируем, `/mnt/` - куда монтируем.
- `sudo umount /mnt/` - вариант отмонтирования с указанием того, ОТКУДА отмонтируем.
- `sudo umount /dev/sda` - вариант отмонтирования с указанием того, ЧТО отмонтируем.

### Итоги

- `Монтирование` - "связка" файла дискового устройства с каталогом.
- `VFS` - Virtual File System
- `/proc/self/moutns` - файл, содержащий информацию о точках монтирования.
- `/etc/fstab` - файл, описывающий точки монтирования при старте ОС.

## 4. Установка ПО

В ОС Linux есть пакетный менеджер который отвечает за локальную установку прграммного обеспечения. Он же строит базы данных в которых есть информация о том, какие пакеты у нас установлены и какой версии. И есть надстройка над этим пакетным менеджером которая работает с репозиториями.  
Пакетный менеджер в Linux Fedora называется `rpm`. А надстройка называется `yum`. В последних версиях Fedora yum был заменён модернизированным менеджером `dnf`.  

Пример установки ПО с помощью `yum`:  

`sudo yum install httpd` - установит пакет httpd и зависимости.  

Чтобы посмотреть что установилось нужно ввести команду:

`rpm -ql httpd` - покажет все файлы которые установлены при установке пакта httpd.

Отфильтруем все найденные файлы по имени каталога bin:

`rpm -ql httpd | grep bin` - выведет все названия с bin.

Исполняемый файл находится в директории /usr/sbin/httpd.

### Поиск пакета по файлу

Для того, что бы найти пакет по имени файла в этом пакете нужно использовать утилиту `yum` с ключём `provides`.

`yum provides *ls` - найдёт ls во всех пакетах, во всех репозиториях.
`yum provides *ls` - немного сузит область поиска, но вывод всё равно будет большой.  
Можно сравнить вывод, добавив в команду `| wc -l` - это счётчик строк.

Если отфильтровать по слову bin, то на выводе будет всего несколько результатов. 

`yum provides | grep bin` - выведет все названия каталогов с bin. Нам нужен каталог `usr/bin/ls`.
Так же можно найти программу ls используя команду `which ls`.

### Список установленных пакетов

Для того, что бы увидеть, что установленно на нашей ОС можно выполнить следующую команду:

`rpm -qa` - выведет весь список установленных пакетов. Чтобы посчитать можно воспользоваться подсчётом строк через `| wc -l`. А через `| grep` можно найти нужный пакет.

Если мы хоти удалить пакет, то можно пойти двумя путями:

1. Использовать `rpm`. Тогда мы локально удалим пакет.
2. Либо использовать `yum`.

Чтобы удалить с помощью `yum` нужно ввести команду:

`sudo yum remove httpd` - удалит пакет httpd. **Но зависимости пакета не удалятся.**

Чтобы удалить с помощью `rpm` нужно ввести команду:

`sudo rpm -e httpd` - удалит пакет httpd. **Но зависимости пакета не удалятся.**

**Итоги**

- `rpm` - работа с пакетами
- `yum` - работа с репозиторием
- для просмотра информации об установленных пакетах нужно использовать `rpm`
- для поиска нужного пакета в репозитории нужно использовать `yum`

## 5. Процессы

### Жизненный цикл процесса

Процесс - это работающая в данный момент программа.  
Академическим языком процесс - это совокупность взаимосвязанных и взаимодействующих действий, преобразующих входящие данные в исходящие.  
Именно процессы работают в нашей ОС. Когда мы говорим "программа" мы подразумеваем совокупность команд понятных системе, либо процессу. А вот когда эти команды начинают исполняться, возникает процесс.  
В ОС Linux создать процесс можно исключительно из существующего процесса. В ОС Linux процесс создаётся путём копирования уже существующего процесса. Системный вызов для создания процесса называется `fork()`. Данный системный вызов создаёт новый процесс из существующего. Он делает полную копию того процесса из которого он был вызван. Системный вызов `fork()` характеризуется следующими свойствами:

- Это системный вызов, создающий новый процесс.
- Создаёт полную копию процесса.
- Стартует в одном процессе, завершается в двух.

После того как мы создали новый процесс, нам нужно внести в него код исполняемой программы. В этом нам помогает системный вызов `exec()`. Он как раз и создаёт нужный нам процесс. Системный вызов `exec()` характеризуется следующими свойствами:

- Это системный вызов, заменяющий исполняемый код в процессе.
- В качестве параметров принимает имя исполняемого файла и параметрый к нему.
- Как правило именно после этого системного вызова мы получаем нужный нам процесс.

Системных вызовов, которые создают и управляют процессами гораздо больше чем 2, но основные это `fork()` и `exec()`.
После того, как процесс отработал, сделал все необходимые действия он завершается. Завершение процесса происходит с помощью системного вызова `exit()`. Он характеризуется следующими свойствами:

- Завершает процесс.
- Освобождает память, которую использовал процесс.
- Закрывает дескрипторы файлов.
- Сообщает код возврата.

Как раз этот процесс возвращает код возврата процесса, с помощью которого мы можем понять завершился наш процесс корректно или некорректно. Корректно - 0. Некорректно - всё остальное. Считывается код возврата специальным системным вызовом `wait()`. Он характеризуется следующими свойствами:

- Вызывается из процесса, который сделал вызов `fork()`.
- Считывает код возврата процесса.
- После того, как у процесса считли код возврата процесс полностью исчезает из системы.

Важный момент заключается в том, что считать код возврата может только тот процесс, из которого произошёл процесс, который сейчас завершился. Процесс из которого был создан новый процесс называется `процесс родитель`, а процесс, который был создан из уже существующего называется `процесс потомок`. Соответственно у каждого процесса родителя есть свой процесс родитель, но, при этом, процесс может не иметь потомков. Есть 2 исключения в ОС Linux это процессы `init()` и `kthreadd()`

Жизненный цикл процесса выглядит следующим образом:

<image src="./images/process.jpg" alt="process">

Рассмотрим полный цикл работы процесса.  
Например мы хотим создать какой-то процесс. Мы делаем системный вызов `fork()` внутри уже существующего процесса, у нас появляется процесс потомок. Затем внутри него мы делаем системный вызов `exec()`, для того, чтобы заменить исполняемый код внутри существующего процесса. Процесс отрабатывает, выполняет все необходимые действия и завершается. Системный вызов `exit()` сообщает код возврата, освобождает все ресурсы, которые были заняты процессом и в этот момент процесс уже не существует в системе как полноценная сущность. Это просто информация в ОС о том, какой процесс как отработал. Код возврата будет считан процессом родителем с помощью системного вызова `wait()`. И только после этого процесс, который был создан системным вызовом `fork()`, будет полностью вычеркнут из ОС.

### PID, PPID, "зомби" и "сироты".

`PID (process identifier)` - это уникальный номер процесса в ОС. Каждый процесс имеет собственный идентификатор в ОС. `PID` характеризуется следующими свойствами:

- Это уникальный номер (идентификатор) процесса.
- В ОС Linux pid хранится в переменной целочисленного типа (int).
- По умолчанию максимальное значение 32768.

Именно по этому идентификатору мы можем обращаться к этому процессу. Но мы знаем, что каждый процесс возник из какого-то существующего процесса и каждый процесс должен иметь информацию от какого процесса он возник. Эта информация называется `PPID (parent process identifier)`. Каждый процесс должен иметь свой `PID` и `PPID`.  
Но в ОС Linux есть 2 исключения. Это процессы `init (PID 1, PPID 0)` и `kthreadd (PID 2, PPID 0)`. При этом, процесс `init()` это пространство пользователя. Он появился в момент старта ядра ОС. В современных ОС Linux он называется `systemd()`.  
Второй процесс `kthreadd()` это процесс в пространстве ядра Linux. Т.е. всё, что возникло в ядре возникло из процесса `kthreadd()`. Так же, стоит заметит, что Linux не существует процесса с `PID 0`.

<image src="./images/init.jpg" alt="init">

Любой процесс в ОС Linux можно так или иначе завершить. Исключение составляет "процесс зомби". 

`Процесс зомби` - это такой процесс, который нельзя завершить. Это состояние между системными вызовами `exit()` и `wait()` от родителя. Это та самая строчка в таблице процессов о том как процесс отработал (строка содержащая PID процесса и код его завершения). Он не занимает ни каких ресурсов. Процесс зомби это обязательное состояние процесса в ОС Linux.

Процесс зомби это по сути индикатор. Наличие процессов зомби (которые будет видны в утилите `top`) показывает 2 следующих момента:

1. У нас очень высоконагруженная система. Как правило сервер будет тормозить, будет высокая загрузка процессора и т.д.
2. У нас есть какой-то процесс, который не следит за своим потомком. Т.е. от него создаётся процесс, который отработал, но не завершился. Потом снова создаётся такой же процесс и т.д. Это некоректная работа одного из процессов, который создаёт своих потомков. Код возврата таких процессов ни кто не считывает и они будут висеть в системе вечно т.к. код возврата имеет право считать только процесс родитель. В этом случает нам нужно найти этот процесс.

Убить процесс зомби можно сделав его `процессом сиротой`.

`Процесс сирота` - это процесс, который остался без родителя. Т.е. у него есть свой PID, а процесса родителя нет. За такими процессами следит ядро и не даёт этим процессам существовать очень долго. Как только появляется процесс сирота ОС производит `усыновление` процесса сироты процессом `init(PID 1)`. Процесс сирота для нас не видим, мы можем увидеть только следствие. 

В ОС Linux процесс это совокупность файлов и данных. Информация о процессах находится в каталоге `/proc` в подкаталоке имя которого будет равно интересующему нас процесса `/proc/<pid>`. Информация о процессах доступна любому пользователю. Управлять процессом может либо пользователь создавший процесс, либо пользователь root. Владелец процесса это и есть пользователь, который его создал. Сменить владельца процесса в Linux невозможно. Как следствие, кто владелец процесса можно уздать, посмотрев кто владалец каталога `/proc/<pid>`.

### Демоны

`Демон` в системах класса UNIX это компьютерная программа, запускаемая самой системой и работающая в фоновом режиме без прямого взаимодействия с пользователем.

<image src="./images/deamon.jpg" alt="deamon">

Термин был придуман программистами Массачусетского технологического института. Он отсылает к персонажу мысленного эксперимента, демону Максвелла, который мог отделить в замкнутом пространстве быстрые молекулы от медленных. 

Технический смысл демонов в следующем:

- Это процесс, который не имеет управляющего терминала.
- С демоном нельзя взаимодействовать с помощью комбинаций клавиш клавиатуры.
- Взаимодействие с демоном происходит с помощью сигналов ОС.

Примерами программ демонов могут являться например apache, nginx, ssh, ntp и т.д. В названии таких программ присуствует буква d (httpd, ntpd, sshd и т.д.)

Взаимодецствие с программами демонами осуществляется с помощью специальной утилиты `kill`. Её формат простой:

- `kill -<signal> <PID>` - `-<signal>` это информация о том какой сигнал мы хотим послать процессу, `<PID>` - PID процесса.

Стандартное назначение сигналов это завершение процесса. Они характеризуются следующими свойствами:

- Названия сигналов "SIG..." являются числовыми константами.
- Обработчик по умолчанию для большинства сигналов завершает выполнение процесса.
- POSIX определяет 28 сигналов.

Наиболее часто применяющиеся сигналы это:

- `SIGINT - 2` - сигнал прерывания (Ctrl-C с терминала).
- `SIGTERM - 15` - сигнал завершения, сигнал по умолчанию для утилиты kill (если не помогает, то 9).
- `SIGKILL - 9` - безусловное завершение.

Отличие сигнала 15 от 9 в том, что 15й сигнал это корректное завершение программы с освобождение всех занятых процессом ресурсов. Так же на него можно написать обработчик в нашей, самописной программе. 9й сигнал мы не сможем вставить в свой обработчик, он не сработает. Это безусловное завершение программы за некоторым исключением:

1. Это процессы со статусом `D`. Это процессы, которые ожидают информацию с устройства ввода-вывода.
2. И процесс `init`.

Кстати, в UNIX исключения на обработку сигнала 9 нет. В FreeBSD, например, можно убить init.


### Утилита TOP

В этой утилите отображаются процессы в системе списком по времени потребления процессорного времени. Чем больше требуется процессорного времени, тем процесс стоит выше. Это динамическая утилита и обновляется достаточно часто, чтобы оценить загруженность процессора (обновляется раз в 3 сек).

<image src="./images/top.jpg" alt="top">

Если нажать `S`, то можно задать время обновления программы.   
В верхней части утилиты top доступна следующая информация:

<image src="./images/toptop.jpg" alt="toptop">

`1я строчка` - сколько сервер в UpTime, т.е. сколько сервер не перезагружался и какое сейчас время на сервере. Какое колличество пользователей сейчас находится на сервере. `load average` - этот параметр является первым показателем загруженности сервера. 1е число - загруженность за 1 мин. 2е число - за 5 мин. 3е число - за 15 мин.  
Говоря академическим языком `load average` это колличество процессов в очереди на ожидание ресурсов.  
Нормальное значение `load average` в **UNIX системах** должно быть равно или меньше колличеству ядер процессора (например FreeBSD). В Linux подобных немного не так.

`2я строчка` - это информация, которая показывает сколько процессов сейчас присутствует в нашей системе и какой у них статус.

`3я строчка сверху` - информация о том, чем сейчас занят процессор. Это усреднённое значение загруженности всех процессоров в системе. Если нажать цифру 1, то мы увидим номер ядра. В этой строке есть следующие параметры:

- `us` - показывает информацию о том, сколько процессорных ресурсов было израсходовано в пространстве пользователя. 
- `sy (system)` - показывает информацию о том, сколько процессорного времени было потрачено на работу ядра ОС (пространство ядра).
- `ni (nice)` - является атавизмом (nice - вежливость). Показывает информацию о том, сколько процессорного времени было потрачено на процессы с пониженным приоритетом. В таблице процессов (ниже), есть параметр `PR (priority)`. Значение по умолчанию 20 и чем ниже это значение, тем выше приоритет процесса.
- `id (idle)` - это процент простоя процессорного времени.
- `wa (wait)` - показывает информацию о том, сколько процессорного времени было потрачено на общение с устройствами ввода-вывода. Если в этом параметре будет 5-10%, то это уже будет сильно ощущаться в производительности.
- `hi (hardware interruption)` - показывает информацию о том, сколько процессорного времени было потрачено на обработку аппаратных прерываний.
- `si (software interruption)` - показывает информацию о том, сколько процессорного времени было потрачено на обработку прерываний программного обеспечения.
- `st (stolen)` - даёт представление о том как занята хостовая машина, т.е. сколько процентов процессорного времени было украдено у нашего компьютера. 

С помощью утилиты `ps` так же можно посмотреть множество параметров процессов ОС. Чтобы запустить эту утилиту в удобном формате вывода достаточно набрать команду:

`ps -efl`

Пример вывода программы `ps`:

<image src="./images/ps.jpg" alt="ps">

Чтобы ещё улучшить визуализацию можно ввесте команду `pstree`Ж

<image src="./images/pstree.jpg" alt="pstree">

### Работа в консоли

Попробуем разобрать какой-нибудь процесс. Т.е. понять как он возник, что делает, какие конфигурационные файлы использует и т.д.  
Всё что касается процессов хранится в каталоге `/proc/`

`ls -l /proc/`  
`ls -l /proc/ | wc -l` - посчитаем сколько процессов у нас в ОС (количество процессов будет выведенное число -1).

Владелец процесса это владелец каталога имя которого равно PID процесса. Всю информацию, которую выводит команда `ps`она берёт из каталога `/proc/`. 
Чтобы узнать сколько всего в системе процессов конкретного пользователя нужно ввести команду:

`ls -ld /proc/* | grep user`

Разберём программу `sshd`, которая отвечает за подключение к серверу по протоколу `ssh`. Выясним какой идентификатор у этой программы:

`ps -efl | grep ssh`

Конфигурационный файл этой программы можно посмотреть если ввести команду (инфо о конфигурационном файле есть в `man sshd`):

`sudo less /etc/ssh/sshd_config` - в этом конфигурационном файле есть полное описание как должен работать `sshd`. 

Чтобы понять объём той информации, которая содержится в `sshd_config` можно задать фильтр:

`sudo grep -v ^# /etc/ssh/sshd_config | grep -v ^$` - `-v ^#` - исключаем символ # в начале строки, `-v ^$` - исключаем из вывода пустые строки (^ - начало строки, $ - конец строки).

## 6. Сеть.

Для отображения сетевых интерфейсов и других параметров сети используются следующие команды:

`ip a (address)` - выведет сетевые интерфейсы сервера, ip-адреса, MAC-адреса адаптеров и т.д.

`ip r (route)` - выведет информацию о шлюзах.

Адрес DNS сервера в Linux прописан в специальном файле `/etc/resolv.conf`. В этом файле есть директива `nameserver` и в качестве аргумента указывается ip адресс. 

Для того, чтобы увидеть информацию о сервисах, которые работают по сети нам необходимо увидеть информацию о портах, которые доступны на нашем сервере. Чтобы увидеть какие порты по протоколу tcp доступны на нашем сервере необходимо ввести команду:

`ss -tnl` - выведет порты, которые слушаюся.  
`sudo ss -tnlp` - выведет название программ, которые слушают порты.  
`sudo ss -unlp` - то же самое, только по протоколу UDP.

## 7. Системы инициализации.

### MBR, GRUB, Kernel

Порядок загрузки компьютера.

<image src="./images/loader.jpg" alt="loader">

Первое что происходит, это запуск программы биос и проверка работоспособности оборудования. После этого, биос смотрит специальную область диска - `MBR` (446 байт), откуда считывает загрузчик `GRUB`, который потом будет использован для загрузки ОС. После этого, идёт загрузка ядра ОС и после ядра вступает в силу система инициализации.  
`MBR (Master Boot Record)` в Linux характеризуется следующими свойствами:

- Это главная загрузочная область.
- Содержит код загрузчика и таблицы разделов.
- Необходима для загрузки ОС.

После того как был считан первичный код загрузчика `GRUB` из `MBR` далее идёт вторая стадия этого загрузчика (как правило весь GRUB не вмещается в MBR). После того, как `GRUB` полностью загрузился, он передаёт управление ОС Linux (загружает ядро Linux). `GRUB` характеризуется следующими свойствами:

- Позволяет пользователю иметь несколько установленных ОС.
- Умеет по цепочке передавать уравление другому загрузчику.
- Самый популярный загрузчик в мире Linux.

Модуль ядра `Kernel` характеризуется следующими свойствами:

- Загрузка ядра Linux
- Ядро должно содержать драйвер диска для каталога `/`
- Если загрузка идёт со специфического диска, то, как правило, сначала вместо реального диска в каталог `/` монтироуется `initrd (Initial RAM Disk)`.

В загружаемом ядре нет драйвера для физической файловой системы которая будет подмонтирована в корневой каталог `/`. Для того, чтобы выйти из этой ситуации, программистами был придуман специальный файл `initrd`. Это архив, который в момент старта ядра монтируется в корневую систему. В этот архив можно положить какие-то модули ядра, которые помогут считать физическую файловую систему и произвести физическую ФС к виртуальной ФС. Т.е. `initrd` предоставляет драйвера для ядра для дальнейшего старта сервисов. Затем мы меняем точку монтирования ФС на реальный физический носитель. После этого начинается старт системы инициализации.

### SysV, upstart, systemd

Система инициализации характеризуется следующими свойствами:

- Стартует после загрузки ядра.
- За систему инициализации отвечает первый процесс (init или systemd).
- Определяет порядок запуска служб и программ.

В мире Linux существует 3 самых популярных систем инициализации: 

- `SysV` - наиболее старая система инициализации, которая пришла из ОС SystemV из мира UNIX. Это набор стартовых скриптов (исполняемых файлов), где есть директивы для командной оболочки, которые чётко рассказывают, что когда и зачем нужно делать. 
- `Upstart` - пришла на смену SysV. Она создавалась для того, чтобы упростить написание стартовых скриптов. Сама инициализация служб в Upstart отличалась от SystemV. В Upstart все службы, которые стартовали имели родителем саму систему Upstart. Широкого распространения не получила.
- `systemd` - является стандартом по умолчанию в большинстве версий ОС Linux, она взяла всё лучшее от Upstart и добавила параллельность запуска. Один из плюсов этой системы является то, что если в процессе пуска служб какая-то служба не запустилась, то systemd будет пытаться запустить её снова. Эта система инициализации наиболее современная и рекомендуемая к использованию.